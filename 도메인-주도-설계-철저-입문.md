## 도메인 주도 설계 철저 입문
나루세 마사노부 지음, 심효섭 옮김. _(자세한 책 소개는 [여기서](https://book.naver.com/bookdb/book_detail.nhn?bid=16778491) 확인하세요.)_

### 01. 도메인 주도 설계란?
* 3쪽: 소프트웨어 개발에서 말하는 도메인은 '프로그램이 쓰이는 대상 분야'라는 의미로 쓰인다.
* 3쪽: 도메인에 포함되는 개념은 시스템의 대상 분야가 무엇인지에 따라 크게 달라진다.
* 4쪽: 주의깊게 관찰하고 관찰을 통해 알게 된 지식을 제대로 표현하는 것은 소프트웨어 개발 과정의 일부다. 도메인 주도 설계에서 소개하는 프랙티스는 이를 실천하는 과정을 보조하는 수단이다.
* 5쪽: 모델은 현실에 일어나는 사건 혹은 개념을 추상화한 개념이다. 추상이란 여러 사물 혹은 개념에서 공통적인 것을 뽑아 파악하는 것으로, 현실의 모든 것을 반영하는 것이 아니다. 상황에 따라 취사선택이 필요하다. 무엇을 버리고 무엇을 취할지는 도메인에 따라 결정된다.
* 5쪽: 사건 혹은 개념을 추상화하는 작업을 모델링이라고 한다. 그리고 모델링의 결과를 모델이라고 한다. 도메인 주도 설계에서는 도메인 개념을 모델링한 모델을 도메인 모델이라고 한다.
* 6쪽: 도메인 객체가 도메인 모델을 충실히 반영하고 있다면 도메인의 변화를 코드로 쉽게 옮길 수 있다.
* 7쪽: 도메인 개념과 도메인 객체는 도메인 모델을 통해 연결되며, 서로 영향을 주고받는 반복적 개발로 실현된다.

### 02. 시스템 특유의 값을 나타내기 위한 '값 객체'
* 16쪽: 도메인 주도 설계에서 말하는 값 객체는 시스템 특유의 값을 나타내는 객체이다.
* 17쪽: 값의 성질은 '변하지 않는다.', '주고 받을 수 있다.', '등가성을 비교할 수 있다.'이다.
* 19쪽: 상태 변화가 원인인 버그를 방지하는 가장 단순한 방법은 상태가 변화하지 않게 하는 것이다.
* 20쪽: 값 객체의 수정 역시 값과 마찬가지로 대입문을 통해 교환의 형식으로 표현된다.
* 22쪽: 값 객체는 시스템 고유의 값이다. 결국 값이다. 따라서 값의 속성을 꺼내 비교하는 것이 아니라, 값과 마찬가지로 직접 값끼리 비교하는 방식이 자연스럽다.
* 27쪽: 도메인 모델로 선정되지 못한 개념을 값 객체로 정의해야 할지에 대한 기준으로 필자는 '규칙이 존재하는가'와 '낱개로 다루어야 하는가'라는 점을 중요하게 본다.
* 30쪽: 값 객체로 정의할 필요가 있는지를 판단하고, 만약 그렇다면 대담하게 행동으로 옮기는 것이 중요하다. 그리고 값 객체로 정의할 만한 가치가 있는 개념을 구현 중에 발견했다면 그 개념은 도메인 모델로 피드백해야 한다. 도메인 주도 설계의 목적인 반복적 개발은 이렇게 구현 중에 발견된 새로운 사실을 통해 이루어진다.
* 32쪽: 값 객체는 결코 데이터를 담는 것만이 목적인 구조체가 아니다. 값 객체는 데이터와 더블어 그 데이터에 대한 행동을 한곳에 모아둠으로써 자신만의 규칙을 갖는 도메인 객체가 된다.
* 33쪽: 값 객체의 장점은 네가지다. '표현력이 증가한다.', '무결성이 유지된다.', '잘못된 대입을 방지한다.', '로직이 코드 이곳저곳에 흩어지는 것을 방지한다.'
* 35쪽: 값 객체는 자기 정의를 통해 자신이 무엇인지에 대한 정보를 제공하는 자기 문서화를 돕는다.
* 36쪽: 값 객체를 잘 이용하면 유효하지 않은 값을 처음부터 방지할 수 있다.
* 40쪽: 값 객체를 정의해 타입 시스템에 의존하면 예측하기 어려운 에러가 숨을 곳을 줄일 수 있다.
* 42쪽: 규칙을 기술한 코드가 한곳에 모여 있다면 수정할 곳도 한곳뿐이라는 의미다. 소프트웨어가 변경을 받아들일 수 있는 유연성을 갖기 위해서는 이러한 작업이 중요하다.
* 43쪽: 값 객체의 개념은 '시스템 고유의 값을 만드는' 단순한 것이다. 원시 타입은 지나치게 범용적이기 때문에 아무래도 표현력이 약하다.

### 03. 생애주기를 갖는 객체 - 엔티티
* 46쪽: 도메인 주도 개발에서 말하는 엔티티는 도메인 모델을 구현한 도메인 객체를 의미한다. 앞서 다룬 값 객체도 도메인 모델을 구현한 도메인 객체다. 이 두가지 객체의 차이는 동일성을 통해 식별이 가능한지 아닌지에 있다.
* 47쪽: 엔티티의 성질은 다음과 같다. '가변이다.', '속성이 같아도 구분할 수 있다.', '동일성을 통해 구별된다.'
* 47쪽: 값 객체는 불변성을 가지고, 엔티티는 가변성을 가진다.
* 49쪽: 가변 객체는 기본적으로 다루기 까다롭다. 가능한 한 객체는 불변으로 남겨두는 습관을 들이는 것이 좋다.
* 50쪽: 엔티티는 값 객체와 달리 속성이 같아도 두 엔티티를 서로 다른 것으로 취급한다.
* 51쪽: 서로 다른 엔티티를 구별하는 데는 식별자가 쓰인다.
* 55쪽: 값 객체는 모든 속성이 비교 대상이었지만, 엔티티 비교는 동일성을 나타내는 식별자만을 대상으로 한다.
* 55쪽: 생애주기를 갖기 않거나 생애주기를 나타내는 것이 무의미한 개념이라면 우선 값 객체로서 다루는 것이 좋다. 생애주기를 갖는 객체는 태어나서 죽을 때까지 변화를 겪을 수 있다. 정확함이 필요한 소프트웨어를 만들려고 할 때 가변 객체는 신중히 다뤄야 할 성가신 존재다. 불변으로 남겨둘 수 있는 것은 최대한 불변 객체로 남겨둬야 시스템을 단순하게 유지할 수 있다.
* 56쪽: 도메인 객체를 정의할 때 장점은 2가지다. '자기 서술적인 코드가 된다.', '도메인에 변경사항이 있을 시 코드에 반영하기 쉽다.'
* 59쪽: 구현 내용과 관련된 규칙이 준수되고 있는지에 대한 판단을 모두 코드에 녹여내야 하며 많은 노력이 필요하다.
* 60쪽: 도메인이 변화할 때마다 소프트웨어도 그에 맞춰 자주 변화해야 한다. 소프트웨어가 미래에도 건강하게 성장해 나가려면 코드에 많은 정보를 담자.
* 60쪽: 엔티티를 구현하려 할 때 애매함을 느꼈다면 도메인을 파악하는 방법을 바꿀 때가 된 것이다.

### 04. 부자연스러움을 해결하는 도메인 서비스
* 62쪽: 소프트웨어 개발에서 말하는 서비스는 클라이언트를 위해 무언가를 해주는 객체를 말한다.
* 62쪽: 서비스는 크게 두 가지로 나뉜다. 첫 번째는 도메인을 위한 서비스고 두 번째는 애플리케이션을 위한 서비스다.
* 64쪽: 사용자명 중복을 확인하는 처리는 User 클래스에 정의돼 있으니 결국 자기 자신에게 중복 여부를 묻는 상황이 된다. 이런 코드는 많은 경우에 개발자를 혼란스럽게 하는 부자연스러운 코드다.
* 65쪽: 도메인 서비스는 자신의 행동을 바꿀 수 있는 인스턴스만의 값을 갖지 않는다는 점에서 값 객체나 엔티티와 다르다.
* 66쪽: 엔티티나 값 객체에 정의하기 부자연스러운 처리는 도메인 서비스에 정의하면 된다.
* 67쪽: 생각 없이 모든 처리 코드를 도메인 서비스로 옮기면 다른 도메인 객체는 그저 데이터를 저장할 뿐, 별다른 정보를 저장할 수 없는 객체가 되는 결과를 낳는다.
* 68쪽: 도메인 객체가 원래 포함했어야 할 지식과 처리 내용을 모두 도메인 서비스나 애플리케이션 서비스에 빼앗겨 자신이 제공할 수 있는 정보가 없는 도메인 객체를 빈혈 도메인 객체 모델이라고 한다. 이런 객체는 데이터와 행위를 함께 모아 놓는다는 객체 지향 설계의 기본 원칙을 정면으로 거스르는 것이다.
* 69쪽: 소프트웨어의 변경에 대한 유연성을 확보하려면 중복되는 코드를 제거하기 위한 노력을 한시도 포기해서는 안 된다.
* 73쪽: 어떤 처리를 도메인 서비스로 만들어야 할지를 판단할 때 그 처리가 모데인에 기초한 것인지를 중요하게 본다. '사용자명 중복'이라는 개념이 도메인에 기초한 것이라면 이를 구현하는 서비스도 도메인 서비스여야 한다. 반대로, 애플리케이션을 만들며 필요하게 된 것이라면 도메인 서비스가 아니다. 그런 처리는 애플리케이션 서비스로 정의해야 한다.

### 05. 데이터와 관련된 처리를 분리하자 - 리포지토리
* 80쪽: 리포지토리는 데이터를 저장하고 복원하는 처리를 추상화하는 객체다.
* 81쪽: 자칫하면 문제 해결을 위한 코드가 이 기술적 요소와 관련된 코드에 침식당하기 때문에 코드의 원래 의도를 알아보기 어려워진다. 리포지토리는 이런 기술적 요소와 관련된 코드를 모아 문제 해결을 위한 코드가 침식되는 것을 막는 역할을 한다.
* 81쪽: 리포지토리의 책임은 도메인 객체를 저장하고 복원하는 퍼시스턴시다.
* 85쪽: 객체의 퍼시스턴시와 관련된 처리를 리포지토리에 맡기면 비즈니스 로직을 더욱 순수하게 유지할 수 있다.
* 87쪽: 인프라를 다루는 처리를 도메인 서비스에 두는 것이 꺼려져 리포지토리에 사용자명 중복 확인을 정의하고 싶다면 구체적인 중복 확인 키를 전달하는 형태가 좋다.
* 89쪽: 비지니스 로직에서 특정한 기술에 의존하는 구현은 바람직하지 않지만, 리포지토리의 구현 클래스라면 특정 기술에 의존하는 구현도 문제가 없다.
* 101쪽: 객체를 저장하려면 저장 대상 객체를 인자로 전달받아야 한다. 따라서 대상 객체의 식별자 및 수정 항목을 인자로 받게 메서드를 정의해서는 안 된다.

### 06. 유스케이스를 구현하기 위한 '애플리케이션 서비스'
* 106쪽: 애플리케이션 서비스를 한마디로 표현하면 유스케이스를 구현하는 객체라고 할 수 있다.
* 113쪽: 도메인 객체의 행동을 호출하는 것은 애플리케이션 서비스의 책임이다. 이 구조가 지켜진다면 도메인 객체의 행동을 호출하는 코드가 모두 애플리케이션 서비스 안에 모여 있지만, 그렇지 않다면 여러 곳에 코드가 흩어질 수 있다.
* 114쪽: 도메인 객체를 직접 공개하지 않는 쪽을 권한다. 도메인 객체는 비공개로 남겨두고 클라이언트에 데이터 전송을 위한 객체(DTO, data transfer obejct)를 만들어 여기에 데이터를 옮겨 넣어 반환하는 방법이다.
* 116쪽: DTO의 생성자 메서드에서 User 객체를 인자로 받는 방법도 코드 수정이 필요한 곳을 줄일 수 있다.
* 118쪽: DTO를 적용하면 DTO를 정의하는 데 필요한 수고와 데이터를 옮겨 담는 데서 오는 약간의 성능 저하가 따르지만, 어지간히 많은 양의 데이터를 옮겨 넣는 것이 아닌 이상 성능 저하는 미미한 수준이다. 오히려 불필요한 의존을 줄이고 도메인 객체의 변경을 방해받지 않는 편익이 더 크다.
* 121쪽: 커맨드 객체를 사용하면 시그니처를 매번 수정할 필요가 없다.
* 126쪽: 도메인 규칙이 애플리케이션 서비스에 기술되면 같은 코드가 여러 곳에서 중복되는 현상이 나타난다.
* 133쪽: 도메인 객체에 규칙을 구현하면 같은 규칙을 구현한 코드가 여러 곳에서 반복되는 것을 방지하고 향후 수정 시에도 수정이 필요한 곳을 빠뜨려 발생하는 버그를 막을 수 있다.
* 133쪽: 응집도가 높으면 모듈이 하나의 관심사에 집중하고 있다는 의미이므로 모듈의 견고성, 신뢰성, 재사용성, 가독성의 측면에서 바람직하다.
* 136쪽: 코드가 처한 맥락과 환경에 따라 오히려 응집도가 낮아지는 선택이 정답일 수도 있다. 그러나 응집도는 클래스를 설계할 때 한 번쯤 고려해볼 만한 가치가 있는 척도임은 틀림없다.
* 142쪽: 애플리케이션 서비스의 인터페이스를 미리 만들어 두면 이를 구현한 목업 객체를 이용해 애플리케이션 서비스의 실제 구현이 완료되기를 기다릴 필요 없이 클라이언트의 구현을 진행할 수 있다.
* 144쪽: 서비스는 클라이언트를 위해 무언가를 해주는 존재다. 값 객체와 엔티티는 자신을 위한 행동을 갖고 있지만, 서비스의 행동은 자신을 위한 것이 아니다. 따라서 서비스는 어떤 사물보다는 활동이나 행동인 경우가 많다.
* 144쪽: 서비스는 자신의 행동을 변화시키는 것을 목적으로 하는 상태를 갖지 않는다. 서비스가 상태를 갖기 않으면 현재 상태를 신경 쓸 필요가 없다는 장점이 있다. 하지만 이를 서비스가 전혀 상태를 갖지 않는다고 이해한다면 잘못 이해한 것이다.
* 146쪽: 상태가 만들어내는 복잡성은 개발자를 혼란스럽게 한다. 상태를 만들지 않을 방법을 먼저 생각해 보는 것이 좋다.
* 146쪽: 도메인 모델을 표현하는 것만으로 애플리케이션이 완성되지 않는다. 애플리케이션 서비스는 도메인 객체를 다루는 데 전념하며 유스케이스를 구현한다.

### 07. 소프트웨어의 유연성을 위한 의존 관계 제어
* 148쪽: 의존 자체를 피하는 것보다는 이를 잘 제어하는 것이 중요하다.
* 
<!--stackedit_data:
eyJoaXN0b3J5IjpbMTY3MDI3MzkwOF19
-->